#-------------------- clone and install requirements-------------
# Clone the Pristi repository clone 
!git clone https://github.com/LMZZML/PriSTI.git

# Navigate into the directory
!cd PriSTI

# Install the required packages
!pip install -r /kaggle/working/PriSTI/requirements.txt

#-------------------- Add Presti to sys.path-------------
import sys
sys.path.append('/kaggle/working/PriSTI') 

#-------------------- Import and set paths-------------
# Imports and paths 
import os, sys, json, yaml, pickle, numpy as np, pandas as pd, torch

# Paths â€“ adjust if your layout differs
PRISTI_ROOT = "./PriSTI"
CONFIG_PATH = f"{PRISTI_ROOT}/config/base.yaml"
WEIGHTS_PATH = f"{PRISTI_ROOT}/save/aqi36/model.pth"   # included in your working tree
MEANSTD_PK = f"{PRISTI_ROOT}/data/pm25/pm25_meanstd.pk"  # from AQI-36 dataset

# Make PriSTI importable
sys.path.append(PRISTI_ROOT)

from main_model import PriSTI_aqi36


#-------------------- Configure and load Presti model -------------
import os, shutil
DEVICE = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# Load config
with open(CONFIG_PATH, "r") as f:
    config = yaml.safe_load(f)

# Load per-sensor mean/std used by AQI-36
with open(MEANSTD_PK, "rb") as f:
    meanstd = pickle.load(f)

# Adjust these depending on the exact structure
#print(type(meanstd))
#print(len(meanstd))
#print(meanstd[0][:5])  # first 5 values of mean
#print(meanstd[1][:5])  # first 5 values of std

mean = np.asarray(meanstd[0], dtype=np.float32)
std  = np.asarray(meanstd[1], dtype=np.float32)
std_safe = np.where(std == 0, 1.0, std)

with open(CONFIG_PATH, "r") as f:
    config = yaml.safe_load(f)

config["model"]["is_unconditional"] = False       
config["model"]["target_strategy"] = "hybrid"
config["diffusion"]["adj_file"] = "AQI36"        
config["seed"] = 42

os.makedirs("./data/pm25/SampleData", exist_ok=True)
shutil.copy(
    "/kaggle/input/airq36/pm25/SampleData/pm25_latlng.txt",
    "./data/pm25/SampleData/pm25_latlng.txt"
)



# Load PriSTI AQI-36 model
model = PriSTI_aqi36(config, DEVICE).to(DEVICE)
state = torch.load(WEIGHTS_PATH, map_location=DEVICE)
model.load_state_dict(state)
model.eval()




